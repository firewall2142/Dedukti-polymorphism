open Api
open Processor

module GenTy : (S with type t = Env.t) = struct
  type t = Env.t

  let envdat = ref (Env.dummy ())

  let handle_entry env e =
    let open Parsers in
    let open Kernel in
    let open Basic in
    let open Entry in
    let (module Pp : Pp.Printer) = Env.get_printer env in
    begin
    match e with
    | Decl (lc, id, scope, st, ty) ->
        Debug.(debug d_notice) "Declaration of constant '%a'." pp_ident id;
        Env.declare env lc id scope st ty
    | Def (lc, id, scope, opaque, ty, te) ->
        let opaque_str = if opaque then " (opaque)" else "" in
        Debug.(debug d_notice)
          "Definition of symbol '%a'%s." pp_ident id opaque_str;
        Env.define env lc id scope opaque te ty
    | Rules (_, rs) ->
        let open Rule in
        List.iter
          (fun (r : partially_typed_rule) ->
            Debug.(
              debug d_notice "Adding rewrite rules: '%a'" Pp.print_rule_name
                r.name))
          rs;
        let rs = Env.add_rules env rs in
        List.iter
          (fun (s, r) ->
            Debug.debug Debug.d_notice "%a@.with the following constraints: %a"
              pp_typed_rule r
              (Exsubst.ExSubst.pp (fun n ->
                   let _, n, _ = List.nth r.ctx n in
                   n))
              s)
          rs
    | Eval (_, red, te) ->
        let te = Env.reduction env ~red te in
        Format.printf "%a@." Pp.print_term te
    | Infer (_, red, te) ->
        let ty = Env.infer env te in
        let rty = Env.reduction env ~red ty in
        Format.printf "%a@." Pp.print_term rty
    | Check (lc, assrt, neg, Convert (t1, t2)) -> (
        let succ = Env.are_convertible env t1 t2 <> neg in
        match (succ, assrt) with
        | true, false  -> Format.printf "YES@."
        | true, true   -> ()
        | false, false -> Format.printf "NO@."
        | false, true  -> raise @@ Entry.Assert_error lc)
    | Check (lc, assrt, neg, HasType (te, ty)) -> (
        let succ = try Env.check env te ty; not neg with _ -> neg in
        match (succ, assrt) with
        | true, false  -> Format.printf "YES@."
        | true, true   -> ()
        | false, false -> Format.printf "NO@."
        | false, true  -> raise @@ Entry.Assert_error lc)
    | DTree (lc, m, v) ->
        let m = match m with None -> Env.get_name env | Some m -> m in
        let cst = mk_name m v in
        let forest = Env.get_dtree env lc cst in
        Format.printf "GDTs for symbol %a:@.%a" pp_name cst Dtree.pp_dforest
          forest
    | Print (_, s) -> Format.printf "%s@." s
    | Name (_, n) ->
        if not (mident_eq n (Env.get_name env)) then
          Debug.(debug d_warn "Invalid #NAME directive ignored.@.")
    | Require (lc, md) -> Env.import env lc md
    end;
    envdat := env

  let get_data _ = !envdat
end

type _ Processor.t += GenTy : (Env.t) t

let equal_foo (type a b) : (a t * b t) -> (a t,b t) Registration.equal option =
  function
  | GenTy, GenTy -> Some (Registration.Refl (GenTy))
  | _ -> None

let () =
  let open Registration in 
  register_processor GenTy {equal = equal_foo} (module GenTy)
